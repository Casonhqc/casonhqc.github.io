---
date: 2023-11-22 19:08:25
modify: 2023-11-22 19:08:25
author: Cason
tags:
  - 二分查找
aliases:
title: 寻找两个正序数组的中位数
categories:
  - 算法笔记
share: true
---
[题目连接](https://leetcode.cn/problems/median-of-two-sorted-arrays/description/?envType=featured-list&envId=2cktkvj?envType=featured-list&envId=2cktkvj)
## 📌 题目分类：二分查找
## 📝 算法流程：
### 思路
这里有两个有序数组，我们要在两个数组中分别确认分割线。分割线左边的所有元素就是合并后数组左半部分（奇数情况下最后一个元素是中位数，偶数情况下是第一个中位数）
**分割线需要满足以下条件**：
1. 两个数组分割线左边加起来的个数和右边一样（如果是奇数，那么左边多一个），对应的表达式是`(m + n + 1) / 2`
2. 第一个数组分割线左边的元素`left1`要小于第二个数组分割线右边的元素`right2`。`left2 < right1`

**我们默认第一个数组比第二个数组短，只需要在第一个数组确认了分割线，那么就相当于在第二个数组确认了分割线**。

对第一个数组进行二分查找，确认分割线（也就是i，它对应第一个分割线左边有几个元素），那么思考红蓝染色法，数组如何染色？**红色代表该下标在分割线的左边，蓝色代表该下标在分割线或者分割线的右边**。那么`left = -1`对应`left对应的下标一定在分割线的左边，如果是0，那么0有可能是分割线，不符合红色定义`， `right = n`对应`right的位置一定是分割线或者分割线的右边`。因为`left = -1`所以只能去判断第二个数组的左边元素

考虑分割线的特殊情况：
对于`i，j`处于边界的情况，需要设置分别设置最大值或者最小值，**重点是让边界位置的元素不会被选中**
![image.png](https://obsidian-1317277327.cos.ap-chengdu.myqcloud.com/attachment/202311221924315.png)


## 🔍 复杂度分析：
- 🕑 时间复杂度：O(log(min(m, n)))，其中 m 和 n 是两个数组的长度。二分查找在较短的数组上进行。
- 💾 空间复杂度：O(1)，仅使用了常数个额外变量。

## 💻 代码：
```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // 确保nums1是较短的数组
        if (nums1.length > nums2.length) {
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        int len1 = nums1.length, len2 = nums2.length;

        // 计算左半部分的总长度
        int leftSize = (len1 + len2 + 1) / 2;
        int left = -1, right = nums1.length;
        while (left + 1 < right) {
            int i = left + (right - left) / 2;
            int j = leftSize - i;

            if (nums2[j - 1] > nums1[i]) {
                left = i;
            } else {
                right = i;
            }
        }

        int i = right;
        int j = leftSize - i;

        // 计算左侧最大值和右侧最小值
        int nums1LeftMax = i == 0 ? Integer.MIN_VALUE : nums1[i - 1];
        int nums1RightMin = i == len1 ? Integer.MAX_VALUE : nums1[i];
        int nums2LeftMax = j == 0 ? Integer.MIN_VALUE : nums2[j - 1];
        int nums2RightMin = j == len2 ? Integer.MAX_VALUE : nums2[j];

        // 根据数组长度的奇偶性计算中位数
        if (((len1 + len2) % 2) == 1) {
            return Math.max(nums1LeftMax, nums2LeftMax);
        } else {
            return (double) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / 2;
        }
    }
}

```




